I want to build a full-stack SaaS web application called SmartClinic.

This is an AI-powered real-time patient queue optimization system for small and mid-sized clinics.

Generate a complete production-ready project structure including:

Backend (FastAPI + Python)

Frontend (React + Vite)

PostgreSQL database

Redis for real-time queue state

WebSocket support

AI model integration structure

Doctor fatigue modeling

Adaptive slot buffering system

Cross-doctor load balancing suggestions

Docker-ready structure

Clean modular architecture

The UI must match a minimalistic SaaS dashboard similar to Stripe / Linear / modern health-tech dashboards.

Focus heavily on clean separation of concerns and modular AI + optimization layers.

üèóÔ∏è 1Ô∏è‚É£ Project Structure

Generate folder structure like:

smartclinic/
 ‚îú‚îÄ‚îÄ backend/
 ‚îÇ   ‚îú‚îÄ‚îÄ app/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai/
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ duration_predictor.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ no_show_predictor.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inflow_forecast.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ severity_analyzer.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fatigue_model.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ buffering_engine.py
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ optimizer/
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.py
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ load_balancer.py
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ websocket/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.py
 ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
 ‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
 ‚îÇ
 ‚îú‚îÄ‚îÄ frontend/
 ‚îÇ   ‚îú‚îÄ‚îÄ src/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layouts/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.jsx
 ‚îÇ   ‚îú‚îÄ‚îÄ package.json
 ‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js
 ‚îÇ
 ‚îú‚îÄ‚îÄ docker-compose.yml
 ‚îî‚îÄ‚îÄ README.md
üóÑÔ∏è 2Ô∏è‚É£ Database Schema (Extended)

Use SQLAlchemy models.

Tables:

patients

id

name

age

visit_type (first_time, follow_up, chronic_management, minor_complaint)

problem_description (TEXT)

ai_severity_score (0‚Äì10)

urgency_score

no_show_probability

created_at

doctors

id

name

specialization

working_hours_start

working_hours_end

max_daily_capacity

fatigue_score

last_break_time

appointments

id

patient_id

doctor_id

predicted_duration

scheduled_start

predicted_start

buffer_allocated

status (waiting, in_consultation, completed, cancelled, no_show)

created_at

queue_events

id

event_type

appointment_id

timestamp

üß† 3Ô∏è‚É£ AI Integration Layer (Extended)
severity_analyzer.py

When a walk-in or emergency is added:

Input:

problem_description (text)

Use NLP model (mock initially) to:

Analyze severity

Output score out of 10

Function:

predict_severity(problem_text) -> float (0-10)

Higher severity automatically pushes patient above lower-rated patients.

duration_predictor.py

Add bias logic:

If visit_type:

first_time ‚Üí +20% duration bias

follow_up ‚Üí -10%

chronic_management ‚Üí +15%

minor_complaint ‚Üí -15%

Structure for XGBoost integration later.

buffering_engine.py (VERY IMPORTANT)

Adaptive Slot Buffering System:

AI dynamically adjusts:

Buffer time between appointments

Emergency reserve %

Inputs:

Predicted inflow from Prophet

Doctor fatigue score

Historical overrun frequency

Time of day

Rules:

More buffer during peak hours

Increase emergency reserve when predicted inflow high

Reduce buffer when demand low

Function:

calculate_dynamic_buffer(doctor_id, timestamp)

Store buffer in appointment.buffer_allocated.

fatigue_model.py

Doctor Fatigue Detection Model

Tracks:

Continuous consultation streak

Overrun frequency

Time since last break

Output:

fatigue_score (0‚Äì100)

break_suggestion (boolean)

Function:

evaluate_fatigue(doctor_id)

If fatigue_score > threshold:

Suggest break window

Increase future buffer allocations automatically

‚öôÔ∏è 4Ô∏è‚É£ Queue Optimization Engine (Upgraded)

scheduler.py

Implement:

Priority queue sorted by:

ai_severity_score

urgency_score

waiting time

Dynamic recalculation of predicted start times

Incorporate buffer from buffering_engine

Account for fatigue-adjusted capacity

Function:

optimize_queue(doctor_id)

Objective:
Minimize weighted waiting time while respecting adaptive buffer constraints.

Structure so OR-Tools can replace heuristic later.

üîÑ 5Ô∏è‚É£ Cross-Doctor Load Balancer

load_balancer.py

If:
Doctor A overloaded
Doctor B underutilized

Suggest:
Auto-transfer of non-specialized cases.

Rules:

Only transfer if specialization matches

Notify admin/staff before reassignment

Function:

suggest_reallocation()

Return suggestions but do not auto-execute without approval.

üñ•Ô∏è 6Ô∏è‚É£ Frontend Enhancements
Walk-in / Emergency Form

When clicking Walk-in or Emergency:

Include:

Name

Age

Visit type dropdown

Problem description (large text input)

After submission:

Display AI severity rating out of 10

Show explanation tooltip

Visit Type Section

Include visit_type selector:

First-time visit

Follow-up

Chronic management

Minor complaint

Display estimated duration adjustment dynamically in UI.

Dashboard Additions

Add:

Doctor Fatigue Indicator

Overload Warning Badge

Transfer Suggestion Card

Buffer Visualization on timeline

üìä 7Ô∏è‚É£ Updated API Workflow

POST /walkin

Accept problem_description

Run predict_severity()

Adjust urgency

Predict duration (with visit_type bias)

Apply adaptive buffer

Insert in queue

Optimize

Broadcast update

POST /emergency

Same as walkin

Severity auto-maximized if critical keywords detected

POST /appointments

Predict duration

Predict no-show

Apply dynamic buffer

Save

Optimize

Broadcast

GET /fatigue/{doctor_id}

Return fatigue score + break suggestion.

GET /load-balance/suggestions

Return doctor reallocation suggestions.

üìà 8Ô∏è‚É£ Analytics Enhancements

GET /analytics should also return:

Fatigue index per doctor

Buffer efficiency metric

Transfer frequency

Severity distribution graph

Peak-hour congestion score

üê≥ 9Ô∏è‚É£ Docker Setup

Include:

PostgreSQL container

Redis container

Backend container

Frontend container

Ensure:

Redis used for live queue

Environment variables for AI models

Scalable service design

üéØ Non-Functional Requirements (Reinforced)

AI service layer isolated

Fatigue + buffering independent modules

Optimizer replaceable with OR-Tools

Event-driven real-time updates

Clean code organization

Future ML upgrade ready

No hard-coded logic

üß† Final Instruction to Replit AI

Generate all starter files with working placeholder logic.

Mock AI models but structure code for:

Real ML model loading

Model retraining integration

Future reinforcement learning scheduler

Ensure modular, production-style code.

Focus on:
Scalability
Maintainability
Separation of concerns
Real-time reliability

add an "add doctor "button in the doctors section
make sure the notifications button works
add an admin login page and give in notifications if the doctors are overworked and give an option to give there doctor a 30 min break or assign only non critical patients, lastly make sure the search patient search bar works
ALSO use this reference images for ui and this is strictly a website which will be used by receptionist at the clinics make sure the profile button works and all the buttons do some job
also add the database using neon db and build it using a base of prisma and make the .env and then ask me for  the neon db key so that you can connect the app to the database
also add the database using neon db and build it using a base of prisma and make the .env and then ask me for the neon db key so that you can connect the app to the database